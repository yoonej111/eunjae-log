# 🔐 KECCAK256

* 이더리움에서 사용되는 암호화 해시 함수
* 데이터를 256비트(32 바이트) 의 고정 길이 해시값으로 변환하는 해시 함수
* 입력이 조금만 변경되어도 결과 값은 크게 달라지며, 이를 통해 데이터의 무결성 검증 가능


#### 1. Keccak256 의 작동 원리

![keccak256](img/blog/keccak256.png)

Keccak256 은 Sponge 구조를 기반으로 하며, 이 구조는 absorb 와 squeeae 두 단계로 나뉜다.

1. Absorb Phase (상태 초기화)

keccak 의 내부 상태는 1600 비트(200 바이트)로 초기화 된다. 이 상태는 5x5 배열의 64비트(8바이트) 블록으로 나뉨.데이터 블록 처리
입력 데이터를 1088 비트(136 바이트) 크기의 블록으로 나누고, 각 블록을 내부 상태와 XOR 연산으로 결합.
결합된 상태를 특정 라운드 함수를 통해 반복적으로 섞음.
위 과정을 모든 입력 블록이 처리 될 때까지 계속됨.

2. Squeeze Phase (출력 생성)

내부 상태에서 고정된 크기의 출력 블록을 추출
필요한 해시값 길이(256 비트) 가 나올 때까지 추출을 반복

#### 2. Keccak256 예제
사실 위 내용만 봤을 때는 명확하게 이해가 되지 않아, 'Hello , world' 라는 입력 데이터를 keccak256 해시 값으로 변환하는 과정을 살펴보자.

⒈ 초기 상태

* 내부 상태는 1600 비트(200 바이트) 크기의 배열로 초기화
* 이 배열은 5x5 크기의 64비트(8 바이트) 블록으로 구성, 초기상태는 모두 0으로 설정
* 각 블록을 S[x][y] 로 표시하면 아래와 같이 나타낼 수 있음

```javascript
s[0][0] = 0
s[0][1] = 0
s[0][2] = 0
s[0][3] = 0
s[0][4] = 0
s[1][0] = 0
s[1][1] = 0
s[1][2] = 0
s[1][3] = 0
s[1][4] = 0
s[2][0] = 0
s[2][1] = 0
s[2][2] = 0
s[2][3] = 0
s[2][4] = 0
s[3][0] = 0
s[3][1] = 0
s[3][2] = 0
s[3][3] = 0
s[3][4] = 0
s[4][0] = 0
s[4][1] = 0
s[4][2] = 0
s[4][3] = 0
s[4][4] = 0
```

⒉ Absorb Phase

데이터 분할, 패딩, XOR 연산이 이 단계에서 수행
hello world 문자열은 12바이트(96 비트) -> keccak256은 데이터를 1088 비트 크기의 블록으러 처리하기 때문에 이를 패딩하여 1088 비트 블록으로 만듬
입력 데이터: hello, world
이진수 표현: 01101000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100
16진수 표현: 68 65 6c 6c 6f 2c 20 77 6f 72 6c 64
위 데이터에 패딩 규칙을 사용하여 블록 크기를 1088비트로 맞춰줌
입력 데이터에 0x01 추가 (96비트 + 8비트 = 104비트)
남은 비트를 0으로 채움 (104비트 + (1088비트 - 104비트 - 1비트))
마지막 비트를 1로 설정
위 데이터로 만들어진 최종 결과
패딩된 블록: 01101000 01100101 01101100 01101100 01101111 00101100 00100000 01110111 01101111 01110010 01101100 01100100 00000001 00000000 00000000 ... 00000000 00000001
16진수 표현: 68 65 6c 6c 6f 2c 20 77 6f 72 6c 64 01 00 ... 00 01
패딩된 데이터 블록을 초기 상태 비트와 XOR 연산으로 결합 
예제 (앞 16비트)
내부 상태 초기값: 00000000 00000000
패딩된 데이터 블록: 01101000 01100101
결과

```javascript
00000000 00000000
XOR
01101000 01100101
-----------------
01101000 01100101
```

이렇게 내부 상태가 갱신되었으면, 이 상태를 여러 번 변환하는 라운드 함수를 적용하여 최종 해시값을 생성.

keccak256 에서는 24번의 라운드 함수가 적용되며, 이 라운드 함수는 다섯 가지 변환 단계로 이루어진다.
1) θ (세타) 변환: 각 비트는 다른 비트와 XOR 연산을 수행하여 상태를 섞음
2) ρ (로) 변환: 각 비트는 특정 위치로 순환 이동
3) π (파이) 변환: 비트 위치가 재배열
4) χ (카이) 변환: 비트 값이 비선형적으로 변경
4) ι (이오타) 변환: 특정 비트에 상수가 XOR 연산으로 추가


3. Absorb Phase

위에서 만들어진 내부 상태의 첫 256 비트를 추출하여 해시값으로 사용